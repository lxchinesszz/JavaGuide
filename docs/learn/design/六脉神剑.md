---
breadcrumb: false
navbar: true
sidebar: true
pageInfo: true
contributor: true
editLink: true
updateTime: true
prev: true
next: true
comment: true
time: 2022-05-24
footer: true
backtotop: true
title: 六大原则 & 23种设计模式
sticky: true
word: true
category: 设计&规范
star: true
original: true
image: https://img.springlearn.cn/blog/learn_1653399918000.png
---

![](https://img.springlearn.cn/blog/learn_1653399918000.png)

## 一、设计模式

设计模式一般分为三类：创建型模式、结构型模式、行为型模式。

- 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。
- 结构型模式：把类或对象结合在一起形成一个更大的结构。
- 行为型模式：类和对象如何交互，及划分责任和算法

![](https://img.springlearn.cn/27c9d5187cd283f8d160ec1ed2b5ac89.jpg)



## 1.1 创建型模式
创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。

1. 单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。
2. 建造者模式 ： 用来创建复杂的复合对象。
3. 工厂方法模式 ：让子类来决定要创建哪个对象。
4. 抽象工厂模式 ：创建多个产品族中的产品对象。
5. 原型模式 ：通过复制原型来创建新对象。

## 1.2 结构型模式

结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

1. 代理模式 ：控制客户端对对象的访问。
2. 组合模式 ：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。
3. 适配器模式 ：将原来不兼容的两个类融合在一起。
4. 装饰者模式 ：为对象添加新功能。
5. 享元模式 ：使用对象池来减少重复对象的创建。
6. 外观模式 ：对外提供一个统一的接口用来访问子系统。
7. 桥接模式 ：将两个能够独立变化的部分分离开来。

## 1.3 行为型模式
行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

1. 策略模式 ：封装不同的算法，算法之间能互相替换。
2. 状态模式 ：根据不同的状态做出不同的行为。
3. 责任链模式 ：将事件沿着链去处理。
4. 观察者模式 ：状态发生改变时通知观察者，一对多的关系。
5. 模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作。
6. 迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素。
7. 备忘录模式 ：保存对象的状态，在需要时进行恢复。
8. 访问者模式 ：稳定数据结构中，定义新的操作行为。
9. 中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介。
10. 解释器模式 ：定义语法，并对其进行解释。
11. 命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。


**总结**
虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。
但是我们也不应该滥用设计模式，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。


## 二、六大原则

## 2.1 开闭原则

**定义**

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

**问题场景**

在软件的生命周期内，因为变化、升级和维护等原因需要`对软件原有代码进行修改时`，可能会`给旧代码中引入错误`，也可能会使我们`不得不对整个功能进行重构`，并且需要原有代码经过重新测试。

**解决方案**

当软件需要变化时，`尽量通过扩展软件实体的行为来实现变化`，而`不是通过修改已有的代码`来实现变化。

**表达**

用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。

**分析**

就是对扩展开放,对修改关闭, 里式替换原则理论支持了这个一说法,及子类要能替换父类,这样子类就可以在父类的基础上,扩展

## 2.2 单一职责原则

**定义**

`一个类只负责一项职责。`

**问题场景**

类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。

**解决方案**

遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。

**表达**

不要让责任扩散

**分析**

一个类,指责要单一,避免如果有多种职责,修改一个职责的时候,误触到其他职责的问题

## 2.3 里氏替换原则

**定义**

所有引用基类的地方必须能透明地使用其子类的对象。

**问题场景**

有一功能P由类A完成，现在要扩展P,其中P由类A的子类B完成，则子类在完成的同时，可能会导致原来功能故障

**解决方案**

当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。

**表达**

使用继承的时候，不要随便修改父类中已经实现的方法

**分析**

子类要能替换父类

## 2.4 依赖倒置原则

**定义**

高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

**问题场景**

类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。

**解决方案**

将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。

**表达**

如果A依赖B，现在要改为依赖C，如果直接修改A有风险，可以让A去依赖一个接口，BC都实现这个接口，也就是策略模式

**分析**

白话就是说,要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换

## 2.5 接口隔离原则

**定义**

客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

**问题场景**

类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则**类B和类D必须去实现他们不需要的方法**。

**解决方案**

将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则

**表达**

防止去实现不需要的接口方法，可以按接口拆分，避免臃肿。

**分析**

白话,接口要最小化,功能更细分. 目的是:不需要的功能,就不要去实现

比如有些接口可能里面什么方法都没有，其存在的意义，就是为了其实现类拥有特殊的功能.所以我们也要怕我们的接口里面没有方法，就怀疑了它存在的价值

```
public class RandomAccess{
}
```

当实现RandomAccess的类比如ArrayList就具有随机访问的能力，而没有实现该接口的，就只能去迭代访问。

我们可以简单的看下Collections下的binarySearch方法的源码

```java 
    public static <T>
    int binarySearch(List<? extends Comparable<? super T>> list, T key) {
        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
            return Collections.indexedBinarySearch(list, key);
        else
            return Collections.iteratorBinarySearch(list, key);
    }
```


## 2.6 迪米特法则


**定义**

一个对象应该对其他对象保持最少的了解。

**问题场景**

类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。

**解决方案**

尽量降低类与类之间的耦合。

**表达**

尽量降低类与类之间的耦合。

**分析**

降低类与类之间直接交互,能隐藏的属性就可以隐藏. eg. 修电脑,去IT部门,之前一直找小张,现在小张走了,还需要重新认识小李. 迪米特法则,就是直接找IT主管,让主管派人修. 主管就是接口，调用接口的方法，底层具体是小张还是小李，我们不用去管

这里其实也强调了接口的重要性!
